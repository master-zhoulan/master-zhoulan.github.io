<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HexoNext分类标签</title>
    <url>/2022/02/02/HexoNext%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>HexoNext主题下分类标签：博客功能模块的增加</p>
<h4 id="主页功能块"><a href="#主页功能块" class="headerlink" title="主页功能块:"></a>主页功能块:</h4><p>编辑hexo项目下主题配置文件:<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim themes/next/_config.yml</span></span><br><span class="line">// 删除前面的注释即代表启用</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h4 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类:"></a>文章分类:</h4><p>进入刚刚生成的index.md:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim source/categories/index.md</span></span><br><span class="line">// 增加<span class="built_in">type</span>属性</span><br><span class="line">title: categories</span><br><span class="line"><span class="built_in">date</span>: 2020-09-26 20:08:39</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>进入需要分类的文章的index.md:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim source/_posts/Blog.md</span></span><br><span class="line">// 增加categories属性为Web</span><br><span class="line">---</span><br><span class="line">title: Blog搭建</span><br><span class="line"><span class="built_in">date</span>: 2020-09-26 19:06:24</span><br><span class="line">tags:</span><br><span class="line">categories: Web</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h4 id="文章标签"><a href="#文章标签" class="headerlink" title="文章标签:"></a>文章标签:</h4><p>进入刚刚生成的index.md:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim source/tags/index.md</span></span><br><span class="line">// 增加<span class="built_in">type</span>属性</span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line"><span class="built_in">date</span>: 2020-09-26 20:08:39</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>进入需要贴标签文章的index.md:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim source/_posts/Blog.md</span></span><br><span class="line">// 将tags的属性为设置为Blog</span><br><span class="line">---</span><br><span class="line">title: Blog搭建</span><br><span class="line"><span class="built_in">date</span>: 2020-09-26 19:06:24</span><br><span class="line">tags: Blog</span><br><span class="line">categories: Web</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面:"></a>关于页面:</h4><p>直接进入index.md编辑即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim source/about/index.md</span></span><br><span class="line">---</span><br><span class="line">title: 关于我</span><br><span class="line"><span class="built_in">date</span>: 2020-09-26 20:19:30</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 如果再也不能见到你，祝你早安，午安，晚安。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QQ：1903585323</span><br><span class="line"></span><br><span class="line">E-mail：[1903585323@qq.com](1903585323@qq.com)</span><br><span class="line"></span><br><span class="line">个人博客：[https://master-zhoulan.github.io/](https://master-zhoulan.github.io/)</span><br><span class="line"></span><br><span class="line">CSDN：[https://i.csdn.net/<span class="comment">#/user-center/profile](https://i.csdn.net/#/user-center/profile)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2022/02/19/KMP/</url>
    <content><![CDATA[<p>题目:<br>KMP<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</span><br><span class="line"></span><br><span class="line">模式串 P</span><br><span class="line"> 在字符串 S</span><br><span class="line"> 中多次作为子串出现。</span><br><span class="line"></span><br><span class="line">求出模式串 P</span><br><span class="line"> 在字符串 S</span><br><span class="line"> 中所有出现的位置的起始下标。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 N</span><br><span class="line">，表示字符串 P</span><br><span class="line"> 的长度。</span><br><span class="line"></span><br><span class="line">第二行输入字符串 P</span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">第三行输入整数 M</span><br><span class="line">，表示字符串 S</span><br><span class="line"> 的长度。</span><br><span class="line"></span><br><span class="line">第四行输入字符串 S</span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，输出所有出现位置的起始下标（下标从 0</span><br><span class="line"> 开始计数），整数之间用空格隔开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤105</span><br><span class="line"></span><br><span class="line">1≤M≤106</span><br><span class="line">输入样例：</span><br><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br><span class="line">输出样例：</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000010;</span><br><span class="line">char p[N], s[N]; // 用 p 来匹配 s</span><br><span class="line">// “next” 数组，若第 i 位存储值为 k</span><br><span class="line">// 说明 p[0...i] 内最长相等前后缀的前缀的最后一位下标为 k</span><br><span class="line">// 即 p[0...k] == p[i-k...i]</span><br><span class="line">int ne[N]; </span><br><span class="line">int n, m; // n 是模板串长度 m 是模式串长度</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    // p[0...0] 的区间内一定没有相等前后缀</span><br><span class="line">    ne[0] = -1;</span><br><span class="line"></span><br><span class="line">    // 构造模板串的 next 数组</span><br><span class="line">    <span class="keyword">for</span> (int i = 1, j = -1; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != -1 &amp;&amp; p[i] != p[j + 1])</span><br><span class="line">        &#123;</span><br><span class="line">            // 若前后缀匹配不成功</span><br><span class="line">            // 反复令 j 回退，直至到 -1 或是 s[i] == s[j + 1]</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + 1]) </span><br><span class="line">        &#123;</span><br><span class="line">            j ++; // 匹配成功时，最长相等前后缀变长，最长相等前后缀前缀的最后一位变大</span><br><span class="line">        &#125;</span><br><span class="line">        ne[i] = j; // 令 ne[i] = j，以方便计算 next[i + 1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // kmp start !</span><br><span class="line">    <span class="keyword">for</span> (int i = 0, j = -1; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span> (j != -1 &amp;&amp; s[i] != p[j + 1])</span><br><span class="line">       &#123;</span><br><span class="line">           j = ne[j];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s[i] == p[j + 1])</span><br><span class="line">       &#123;</span><br><span class="line">           j ++; // 匹配成功时，模板串指向下一位</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (j == n - 1) // 模板串匹配完成，第一个匹配字符下标为 0，故到 n - 1</span><br><span class="line">       &#123;</span><br><span class="line">           // 匹配成功时，文本串结束位置减去模式串长度即为起始位置</span><br><span class="line">           cout &lt;&lt; <span class="string">i - j &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           // 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line"><span class="string">           // 需要让 j 回退到一定位置，再让 i</span> 加 1 继续进行比较</span><br><span class="line">           // 回退到 ne[j] 可以保证 j 最大，即已经成功匹配的部分最长</span><br><span class="line">           j = ne[j]; </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown进阶</title>
    <url>/2022/01/19/Markdown2/</url>
    <content><![CDATA[<p>好了，常用的 Markdown 语法至此我们已经基本学习完毕了,然后我们就可 以根据这些语法去书写我们的博客内容啦,下面再提供几个比较高级的玩法：<br> <span id="more"></span></p>
<h4 id="1）模板设置"><a href="#1）模板设置" class="headerlink" title="(1）模板设置"></a>(1）模板设置</h4><p>当我们使用命令hexo new “title” 去创建我们的文章时，Hexo 会根据 &#x2F;scaffolds&#x2F;post.md 文件对新建文件进行初始化，换言之，&#x2F;scaffolds&#x2F;post.md 文件就是创建新文章的模板，所以我们可以修改它来适应自己的写作习惯，一个简单的示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; tiltle &#125;&#125;</span><br><span class="line"><span class="built_in">date</span>: &#123;&#123; <span class="built_in">date</span> &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories: </span><br></pre></td></tr></table></figure>

<h4 id="2）头部设置"><a href="#2）头部设置" class="headerlink" title="(2）头部设置"></a>(2）头部设置</h4><p>在每一篇博客文章的开头都会有对文章的说明文字，叫做 文章头部，文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以对文章添加标签、分类等，一个简单的示例如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: Title</span><br><span class="line"><span class="built_in">date</span>: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tags1, tags2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure>
<h4 id="3）首页显示"><a href="#3）首页显示" class="headerlink" title="(3）首页显示"></a>(3）首页显示</h4><p>在 Hexo 框架搭建的博客网站首页会显示文章的内容（默认显示文章的全部内容），如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简，只需在文章中使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>标志，表示只会显示标志前面的内容</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie字符串统计</title>
    <url>/2022/02/20/Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>题目<br>Trie字符串统计<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">维护一个字符串集合，支持两种操作：</span><br><span class="line"></span><br><span class="line">I x 向集合中插入一个字符串 x</span><br><span class="line">；</span><br><span class="line">Q x 询问一个字符串在集合中出现了多少次。</span><br><span class="line">共有 N</span><br><span class="line">个操作，所有输入的字符串总长度不超过 105</span><br><span class="line">，字符串仅包含小写英文字母。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N</span><br><span class="line">，表示操作数。</span><br><span class="line"></span><br><span class="line">接下来 N</span><br><span class="line">行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x</span><br><span class="line">在集合中出现的次数。</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"></span><br><span class="line">1≤N≤2∗104</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br><span class="line"></span><br><span class="line">输出样例：</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>题解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26],cnt[N],idx;//cnt表示出现的次数 idx是trie的节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">void insert(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    <span class="keyword">for</span>(int i = 0;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;  //没有该子结点就创建一个</span><br><span class="line">        p = son[p][u]; //走到p的子结点，理解为链表指向下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line">//重新遍历一遍 如果路径不通就返回0</span><br><span class="line">int query(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    <span class="keyword">for</span>(int i = 0;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="built_in">return</span> 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        scanf(<span class="string">&quot;%s%s&quot;</span>,op,str);</span><br><span class="line">        <span class="keyword">if</span>(op[0] == <span class="string">&#x27;I&#x27;</span>) insert(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2022/01/18/my-first-blog/</url>
    <content><![CDATA[<p>在了解Markdown 语法之前，博主十分强烈推荐csdn编辑器markdown,十分方便好用，还可以实时预览，如果有更好的编辑器可以推荐给我哦~</p>
<h4 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h4><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Markdown 语法:</span><br><span class="line">1.<span class="comment"># 一级标题</span></span><br><span class="line">2.<span class="comment">## 二级标题</span></span><br><span class="line">3.<span class="comment">### 三级标题</span></span><br><span class="line">4.<span class="comment">#### 四级标题</span></span><br><span class="line">5.<span class="comment">##### 五级标题</span></span><br><span class="line">6.<span class="comment">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<h4 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Markdown语法:</span><br><span class="line"></span><br><span class="line">1.* 斜体 *</span><br><span class="line">2.** 粗体 **</span><br><span class="line">3.*** 加粗斜体 ***</span><br><span class="line">4.~~ 删除线 ~~</span><br></pre></td></tr></table></figure>
<p>Typora快捷键  </p>
<blockquote>
<p>ctrl+b: 粗体</p>
</blockquote>
<h4 id="（3）引用快"><a href="#（3）引用快" class="headerlink" title="（3）引用快"></a>（3）引用快</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Markdown 语法:</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&gt;&#x27;</span>文字引用</span><br><span class="line">Typora快捷键: ctrl+<span class="built_in">shift</span> +q</span><br></pre></td></tr></table></figure>

<h4 id="（4）代码块"><a href="#（4）代码块" class="headerlink" title="（4）代码块"></a>（4）代码块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Markdown语法:</span><br><span class="line">1.行内代码</span><br><span class="line">2....</span><br><span class="line">3.多行代码</span><br><span class="line">4.多行代码</span><br><span class="line">5.```</span><br></pre></td></tr></table></figure>
<h4 id="（5）代码块"><a href="#（5）代码块" class="headerlink" title="（5）代码块"></a>（5）代码块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h4 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.方法一:</span><br><span class="line">2.方法二:+++</span><br><span class="line">3.方法三:***</span><br><span class="line">使用以上三种方法都可以</span><br></pre></td></tr></table></figure>
<h4 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 有序列表项</span><br><span class="line">*无序列表项</span><br><span class="line">+无序列表项</span><br></pre></td></tr></table></figure>

<h4 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure>
<h4 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方法一:[链接文字](<span class="string">&#x27;链接地址&#x27;</span> <span class="string">&quot;链接描述&quot;</span>)</span><br><span class="line">例如:[我的博客](https://github.com)</span><br><span class="line"></span><br><span class="line">方法二:&lt;链接地址&gt;</span><br><span class="line">例如:&lt;https://github.com&gt;</span><br></pre></td></tr></table></figure>
<h4 id="（10）超链接"><a href="#（10）超链接" class="headerlink" title="（10）超链接"></a>（10）超链接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![图片文字](<span class="string">&#x27;图片地址&#x27;</span> <span class="string">&quot;图片描述&quot;</span>)</span><br><span class="line">例如: ![示例图片](http://www.example.com)</span><br></pre></td></tr></table></figure>

<p>说明：在Hexo中插入图片时，请按照以下步骤进行设置</p>
<p>（1）将站点配置文件中的 post_asset_folde选项设置成 true</p>
<p>（2）在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save安装插件</p>
<p>（3）此时使用 hexo new title 创建文章时，将同时在 source&#x2F;_post 文件夹中生成一个与 title 同名的文件夹，我们只需将待添加的图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p>
<p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加了图片 example.PNG，则可以在对应的文章中使用语句<img src="/title/example.PNG" alt="示例图片" title="示例图片"> 添加图片</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>合并集合</title>
    <url>/2024/02/23/%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>题目：合并集合<br> <span id="more"></span></p>
<figure class="highlight plaintext"><figcaption><span>js</span></figcaption><table><tr><td class="code"><pre><span class="line">一共有 n</span><br><span class="line"> 个数，编号是 1∼n</span><br><span class="line">，最开始每个数各自在一个集合中。</span><br><span class="line"></span><br><span class="line">现在要进行 m</span><br><span class="line"> 个操作，操作共有两种：</span><br><span class="line"></span><br><span class="line">M a b，将编号为 a</span><br><span class="line"> 和 b</span><br><span class="line"> 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</span><br><span class="line">Q a b，询问编号为 a</span><br><span class="line"> 和 b</span><br><span class="line"> 的两个数是否在同一个集合中；</span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 n</span><br><span class="line"> 和 m</span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">接下来 m</span><br><span class="line"> 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问指令 Q a b，都要输出一个结果，如果 a</span><br><span class="line"> 和 b</span><br><span class="line"> 在同一集合内，则输出 Yes，否则输出 No。</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤n,m≤105</span><br><span class="line">输入样例：</span><br><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br><span class="line">输出样例：</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">并查集：</span><br><span class="line">1.将两个集合合并</span><br><span class="line">2.询问两个元素是否在一个集合当中</span><br><span class="line"></span><br><span class="line">基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。</span><br><span class="line">每个节点储存它的父节点，p[x]表示x父节点</span><br><span class="line"></span><br><span class="line">问题1：如何判断树根：<span class="keyword">if</span>(p[x] == x)</span><br><span class="line">问题2：如何求想的集合编号：<span class="keyword">while</span>(p[x] != x) x = p[x];</span><br><span class="line">问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号。p[x]</span><br><span class="line"> = y</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"> using namespace std;</span><br><span class="line"> const int N = 100010;</span><br><span class="line"> </span><br><span class="line"> int n,m;</span><br><span class="line"> int p[x];</span><br><span class="line"> </span><br><span class="line"> int find(int x)  //利用递归查找根节点</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]); </span><br><span class="line">   <span class="built_in">return</span> p[x];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int <span class="function"><span class="title">main</span></span>()</span><br><span class="line"> &#123;</span><br><span class="line">   scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">   <span class="keyword">for</span>(int i = 0;i &lt; n;i++) p[i] = i;</span><br><span class="line">   <span class="keyword">while</span>(m--)</span><br><span class="line">   &#123;</span><br><span class="line">     char op[2];</span><br><span class="line">     int a,b;</span><br><span class="line">     scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">     <span class="keyword">if</span>(op[0] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       p[find[a]] = find(b);</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(a) == find(b))</span><br><span class="line">        puts(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        puts(<span class="string">&quot;no&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2024/03/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p>题目：字符串哈希<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1]</span><br><span class="line"> 和 [l2,r2]这两个区间所包含的字符串子串是否完全相同。</span><br><span class="line"></span><br><span class="line">字符串中只包含大小写英文字母和数字。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n 和 m，表示字符串长度和询问次数。</span><br><span class="line"></span><br><span class="line">第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。</span><br><span class="line"></span><br><span class="line">接下来 m 行，每行包含四个整数 l1,r1,l2,r2，表示一次询问所涉及的两个区间。</span><br><span class="line"></span><br><span class="line">注意，字符串的位置从 1 开始编号。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤n,m≤105</span><br><span class="line">输入样例：</span><br><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br><span class="line">输出样例：</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">难度：简单</span><br><span class="line">时/空限制：1s / 64MB</span><br><span class="line">总通过数：60100</span><br><span class="line">总尝试数：91336</span><br><span class="line">来源：</span><br><span class="line">模板题</span><br><span class="line">算法标签</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef unsigned long long ULL;</span><br><span class="line">const int N = 1e5+5,P = 131;//131 13331</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"></span><br><span class="line">// h[i]前i个字符的<span class="built_in">hash</span>值</span><br><span class="line">// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字</span><br><span class="line">// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突</span><br><span class="line">// 使用场景： 两个字符串的子串是否相同</span><br><span class="line">ULL query(int l,int r)&#123;</span><br><span class="line">    <span class="built_in">return</span> h[r] - h[l-1]*p[r-l+1];  //ABCDE-ABC00 DE哈希值</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    string x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    //字符串从1开始编号，h[1]为前一个字符的哈希值</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    h[0] = 0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        p[i+1] = p[i]*P;            //p进制的位数</span><br><span class="line">        h[i+1] = h[i]*P +x[i];      //前缀和求整个字符串的哈希值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        int l1,r1,l2,r2;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        <span class="keyword">if</span>(query(l1,r1) == query(l2,r2)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2024/02/27/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目：堆排序<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n 和 m。</span><br><span class="line"></span><br><span class="line">第二行包含 n 个整数，表示整数数列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含 m 个整数，表示整数数列中前 m 小的数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤m≤n≤105，</span><br><span class="line">1≤数列中元素≤109</span><br><span class="line">输入样例：</span><br><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br><span class="line">输出样例：</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int n,m;</span><br><span class="line">int h[N];</span><br><span class="line">int sized;</span><br><span class="line"></span><br><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * 2 &lt;= sized &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;</span><br><span class="line">    <span class="keyword">if</span>(u * 2 + 1 &lt;= sized &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u],h[t]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(int i = 1;i &lt;= n;i++) scanf(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    sized = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = n/2;i;i--) down(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[1]);</span><br><span class="line">        h[1] = h[sized];</span><br><span class="line">        sized --;</span><br><span class="line">        down(1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>最大异或对</title>
    <url>/2022/02/21/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/</url>
    <content><![CDATA[<p>题目：最大异或对<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在给定的 N</span><br><span class="line"> 个整数 A1，A2……AN</span><br><span class="line"> 中选出两个进行 xor</span><br><span class="line">（异或）运算，得到的结果最大是多少？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入一个整数 N</span><br><span class="line"></span><br><span class="line">第二行输入 N个整数 A1～AN</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数表示答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤105</span><br><span class="line">0≤Ai&lt;231</span><br><span class="line">输入样例：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">输出样例：</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int const N=100010,M=31*N;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">int son[M][2],idx;</span><br><span class="line">//M代表一个数字串二进制可以到多长</span><br><span class="line"></span><br><span class="line">void insert(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int p=0;  //根节点</span><br><span class="line">    <span class="keyword">for</span>(int i=30;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=x&gt;&gt;i&amp;1;   /////取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; ///如果插入中发现没有该子节点,开出这条路</span><br><span class="line">        p=son[p][u]; //指针指向下一层</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int search(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int p=0;int res=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=30;i&gt;=0;i--)</span><br><span class="line">    &#123;                               ///从最大位开始找</span><br><span class="line">        int u=x&gt;&gt;i&amp;1;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u]) ////如果当前层有对应的不相同的数</span><br><span class="line">        &#123;   ///p指针就指到不同数的地址</span><br><span class="line"></span><br><span class="line">          p=son[p][!u];</span><br><span class="line">          res=res*2+1;</span><br><span class="line">             ///*2相当左移一位  然后如果找到对应位上不同的数res+1 例如    001</span><br><span class="line">        &#125;                                                       ///       010 </span><br><span class="line">        <span class="keyword">else</span>                                            ////          ---&gt;011                                                                           //刚开始找0的时候是一样的所以+0    到了0和1的时候原来0右移一位,判断当前位是同还是异,同+0,异+1</span><br><span class="line">        &#123;</span><br><span class="line">            p=son[p][u];</span><br><span class="line">            res=res*2+0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    idx=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        res=max(res,search(a[i]));  ///search(a[i])查找的是a[i]值的最大与或值</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">res&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟散列表</title>
    <url>/2024/02/29/%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>题目：模拟散列表<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">维护一个集合，支持如下几种操作：</span><br><span class="line"></span><br><span class="line">1. I x，插入一个整数 x；</span><br><span class="line">2. Q x，询问整数 x 是否在集合中出现过；</span><br><span class="line">现在要进行 N 次操作，对于每个询问操作输出对应的结果。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N，表示操作数量。</span><br><span class="line"></span><br><span class="line">接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出 Yes，否则输出 No。</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤105</span><br><span class="line"></span><br><span class="line">−109≤x≤109</span><br><span class="line">输入样例：</span><br><span class="line">5</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">Q 2</span><br><span class="line">Q 5</span><br><span class="line">输出样例：</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>js</span></figcaption><table><tr><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100003;</span><br><span class="line">int h[N],e[N],ne[N],idx;//h哈希表</span><br><span class="line"></span><br><span class="line">int insert(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int k = (x % N + N) % N; // 保证负数不出错</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool query(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int k = (x % N + N ) % N;</span><br><span class="line">    for(int i = h[k];i != -1;i = ne[i])</span><br><span class="line">        if(e[i] == x)</span><br><span class="line">            return true;</span><br><span class="line">            </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    </span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%s%d&quot;,op,&amp;x);</span><br><span class="line">        </span><br><span class="line">        if(*op == &#x27;I&#x27;) insert(x);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(query(x)) puts(&quot;Yes&quot;);</span><br><span class="line">            else puts(&quot;No&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟堆</title>
    <url>/2024/02/28/%E6%A8%A1%E6%8B%9F%E5%A0%86/</url>
    <content><![CDATA[<p>题目：模拟堆<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">维护一个集合，初始时集合为空，支持如下几种操作：</span><br><span class="line">1. I x，插入一个数 x；</span><br><span class="line">2. PM，输出当前集合中的最小值；</span><br><span class="line">3. DM，删除当前集合中的最小值（数据保证此时的最小值唯一）；</span><br><span class="line">4. Dk，删除第 k 个插入的数；</span><br><span class="line">5. Ckx，修改第 k 个插入的数，将其变为 x ；</span><br><span class="line">现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N</span><br><span class="line"></span><br><span class="line">接下来 N 行，每行包含一个操作指令，操作指令为 I x，PM，DM，Dk 或 Ckx 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个输出指令 PM，输出一个结果，表示当前集合中的最小值。</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤105</span><br><span class="line"></span><br><span class="line">−109≤x≤109</span><br><span class="line"></span><br><span class="line">数据保证合法。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line">8</span><br><span class="line">I -10</span><br><span class="line">PM</span><br><span class="line">I -10</span><br><span class="line">D 1</span><br><span class="line">C 2 8</span><br><span class="line">I 6</span><br><span class="line">PM</span><br><span class="line">DM</span><br><span class="line">输出样例：</span><br><span class="line">-10</span><br><span class="line">6</span><br><span class="line">难度：简单</span><br><span class="line">时/空限制：1s / 64MB</span><br><span class="line">总通过数：47861</span><br><span class="line">总尝试数：121678</span><br><span class="line">来源：</span><br><span class="line">模板题</span><br><span class="line">算法标签</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            int u=ph[k];                //这里一定要用u=ph[k]保存第k个插入点的下标</span><br><span class="line">            heap_swap(u,cur_size);          //因为在此处heap_swap操作后ph[k]的值已经发生 </span><br><span class="line">            cur_size--;                    //如果在up,down操作中仍然使用ph[k]作为参数就会发生错误</span><br><span class="line">            up(u);</span><br><span class="line">           down(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            h[ph[k]]=x;                 //此处由于未涉及heap_swap操作且下面的up、down操作只会发生一个所以</span><br><span class="line">            down(ph[k]);                //所以可直接传入ph[k]作为参数</span><br><span class="line">            up(ph[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>食物链</title>
    <url>/2024/02/26/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<p>题目：食物链<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。</span><br><span class="line">A吃B，B吃C,C吃A。</span><br><span class="line"></span><br><span class="line">现有 N个动物，以 1∼N编号。</span><br><span class="line"></span><br><span class="line">每个动物都是 A,B,C中的一种，但是我们并不知道它到底是哪一种。</span><br><span class="line"></span><br><span class="line">有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</span><br><span class="line"></span><br><span class="line">第一种说法是 1 X Y，表示 X和Y是同类。</span><br><span class="line"></span><br><span class="line">第二种说法是 2 X Y，表示 X 吃 Y。</span><br><span class="line"></span><br><span class="line">此人对 N 个动物，用上述两种说法，一句接一句地说出 K句话，这 K 句话有的是真的，有的是假的。</span><br><span class="line"></span><br><span class="line">当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</span><br><span class="line"></span><br><span class="line">当前的话与前面的某些真的话冲突，就是假话；</span><br><span class="line">当前的话中 X 或 Y 比 N大，就是假话；</span><br><span class="line">当前的话表示 X 吃 X，就是假话。</span><br><span class="line">你的任务是根据给定的 N 和 K 句话，输出假话的总数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行是两个整数 N 和 K，以一个空格分隔。</span><br><span class="line"></span><br><span class="line">以下 K 行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中 D 表示说法的种类。</span><br><span class="line"></span><br><span class="line">若 D=1，则表示 X 和 Y 是同类。</span><br><span class="line"></span><br><span class="line">若 D=2，则表示 X 吃 Y。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">只有一个整数，表示假话的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤50000,</span><br><span class="line">0≤K≤100000</span><br><span class="line">输入样例：</span><br><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br><span class="line">输出样例：</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>js</span></figcaption><table><tr><td class="code"><pre><span class="line">//用并查集来维护额外信息：d[]</span><br><span class="line">//此外在运用“并查集”解题时要注意：并查集中每个集合时一个树的形式</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=5*1e4+10;</span><br><span class="line">int n,m;</span><br><span class="line">//father数组，辅助数组-维护i节点到根节点的距离（因为初始每个节点都为根节点，所以距离初始都为0 ）</span><br><span class="line">int p[N],d[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//路径的长度（高度），是需要自上而下加起来的，从根节点往下走,所以要先调用递归</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    if(p[x]!=x)&#123;</span><br><span class="line">        int t=find(p[x]);//t暂时存p[x]“根”节点</span><br><span class="line">        d[x]+=d[p[x]]; //find之后，p[x]存放p[x]到根节点之间的距离了；原d[x]为x到父节点之间的距离</span><br><span class="line">        //路劲压缩优化</span><br><span class="line">        p[x]=t; </span><br><span class="line">    &#125;</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此题：</span><br><span class="line">//不管是否为同类还是异类，都把他放在同一集合中 ，即：只要知道了两个动物的关系就把他们放在集合里面去。这样，就可以间接得出各动物之间的关系</span><br><span class="line">//核心：如何确定每个点之间的关系？=》如何确定每个点与根节点之间的关系？</span><br><span class="line">//通过到根节点模上3的距离来判断：1表示可以吃根节点，2表示被根节点吃，3表示与根节点是同类</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int r,x,y; //r标识说法的种类</span><br><span class="line">        cin&gt;&gt;r&gt;&gt;x&gt;&gt;y;</span><br><span class="line"></span><br><span class="line">        if(x&gt;n||y&gt;n)  //三大“假条件”之二</span><br><span class="line">            res++; </span><br><span class="line">        else&#123;</span><br><span class="line">            int px=find(x),py=find(y); //px和py都是根节点</span><br><span class="line">            //r=1表示x和y是同类</span><br><span class="line">            if(r==1)&#123;</span><br><span class="line">                //px==py说明x和y已经在同一颗树上了</span><br><span class="line">                //x和y若是同一种类，则他们到根节点的距离模3应该相等</span><br><span class="line">                if(px==py &amp;&amp; (d[x]-d[y])%3) res++;</span><br><span class="line">                else if(px!=py)&#123;</span><br><span class="line">                    //让x的祖宗节点指向y的祖宗节点</span><br><span class="line">                    p[px]=py;</span><br><span class="line">                    //定义px到py之间的距离：因为x和y是同类，所以x合并到y的集合中后，(d[x]+?)%3==d[y]%3 =&gt; d[y]-d[x]=?,其中？为x的祖宗节点px到y的祖宗节点的距离</span><br><span class="line">                    d[px]=d[y]-d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            //r=2表示x吃y</span><br><span class="line">            // =》x到根节点的距离比y到根节点的距离多1 =》(d[x]-d[y]-1)%3==0</span><br><span class="line">            &#125;else if(r==2)&#123;</span><br><span class="line">                if(px==py &amp;&amp; (d[x]-d[y]-1)%3) res++;</span><br><span class="line">                else if(px!=py)&#123;  //x和y不在同一集合中</span><br><span class="line">                    p[px]=py;</span><br><span class="line">                    //因为x吃y，所以d[x]+?-d[y]-1==0 =&gt; ?=d[y]+1-d[x],其中？为d[px]</span><br><span class="line">                    d[px]=d[y]+1-d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2024/03/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>题目：背包问题<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span><br><span class="line"></span><br><span class="line">第 i 件物品的体积是 vi，价值是 wi。</span><br><span class="line"></span><br><span class="line">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</span><br><span class="line"></span><br><span class="line">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">0&lt;N,V≤1000</span><br><span class="line"></span><br><span class="line">0&lt;vi,wi≤1000</span><br><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">输出样例：</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line">int v[N],w[N]; //v重量，w价值</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // <span class="keyword">for</span>(int i = 1;i &lt;=n ;i++)</span><br><span class="line">    //     <span class="keyword">for</span>(int j = 0;j &lt;=m;j++)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         f[i][j] = f[i -1][j];</span><br><span class="line">    //         <span class="keyword">if</span>(j &gt;= v[i])</span><br><span class="line">    //             f[i][j] = max(f[i][j] ,f[i-1][j - v[i]] + w[i]);</span><br><span class="line">    //     &#125;</span><br><span class="line">        </span><br><span class="line">    // int res = 0;</span><br><span class="line">    // <span class="keyword">for</span>(int i = 0;i &lt;= m;i++) res = max(res,f[n][i]);</span><br><span class="line">    </span><br><span class="line">    // cout &lt;&lt; <span class="string">res &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    for(int i = 1;i&lt;=n;i++)  // 第i个物品分别在容量从大到小放置的状态</span></span><br><span class="line"><span class="string">        for(int j = m;j&gt;=v[i];j--)</span></span><br><span class="line"><span class="string">            f[j] = max(f[j],f[j - v[i]] + w[i]);  // 在最后一轮才能知道背包在不同容量下的最大价值</span></span><br><span class="line"><span class="string">    cout&lt;&lt;f[m]&lt;&lt;endl;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2022/02/18/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>题目:<br>滑动窗口<br> <span id="more"></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给定一个大小为 n&lt;=106的数组</span><br><span class="line"></span><br><span class="line">有一个大小为 k的滑动窗口,它从数组的最左边移动到最右边</span><br><span class="line"></span><br><span class="line">你只能在窗口中看到 k个数字</span><br><span class="line"></span><br><span class="line">每次滑动窗口向右移动一个位置</span><br><span class="line"></span><br><span class="line">以下是一个例子:</span><br><span class="line"></span><br><span class="line">该数组为 [1 3 -1 -3 5 3 6 7],k为 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">窗口位置	最小值	最大值</span><br><span class="line">[1 3 -1] -3 5 3 6 7	-1	3</span><br><span class="line">1 [3 -1 -3] 5 3 6 7	-3	3</span><br><span class="line">1 3 [-1 -3 5] 3 6 7	-3	5</span><br><span class="line">1 3 -1 [-3 5 3] 6 7	-3	5</span><br><span class="line">1 3 -1 -3 [5 3 6] 7	3	6</span><br><span class="line">1 3 -1 -3 5 [3 6 7]	3	7</span><br><span class="line">你的任务是确定滑动窗口位于每个位置时,窗口中的最大值和最小值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包含两行.</span><br><span class="line"></span><br><span class="line">第一行包含两个整数 n和 k</span><br><span class="line">,分别代表数组长度和滑动窗口的长度</span><br><span class="line"></span><br><span class="line">第二行有 n个整数,代表数组的具体数值</span><br><span class="line"></span><br><span class="line">同行数据之间用空格隔开</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出包含两个</span><br><span class="line"></span><br><span class="line">第一行输出,从左至右,每个位置滑动窗口中的最小值</span><br><span class="line"></span><br><span class="line">第二行输出,从左至右,每个位置滑动窗口中的最大值</span><br><span class="line"></span><br><span class="line">输入样例:</span><br><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br><span class="line">输出样例:</span><br><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<p>C++代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1000010;</span><br><span class="line">int a[N], q[N], hh, tt = -1;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i - k + 1 &gt; q[hh]) ++ hh;                  // 若队首出窗口，hh加1</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1</span><br><span class="line">        q[++ tt] = i;                                  // 下标加到队尾</span><br><span class="line">        <span class="keyword">if</span> (i + 1 &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);       // 输出结果</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">    hh = 0; tt = -1;                                   // 重置！</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; n; ++ i)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        if (i - k + 1 &gt; q[hh]) ++ hh;</span></span><br><span class="line"><span class="string">        while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;</span></span><br><span class="line"><span class="string">        q[++ tt] = i;</span></span><br><span class="line"><span class="string">        if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
</search>
